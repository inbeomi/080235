#
# 아이템 11
#
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print('가운데 2개: ', a[3:5])
print('마지막을 제외한 나머지:', a[1:7])
assert a[:5] == a[0:5] # 리스트의 맨 앞부터 슬라이싱할 때는 시각적 잡음을 없애기 위해 0을 생략해야 한다. 
assert a[5:] == a[5:len(a)] # 끝도 마찬가지이다. 
a[:]     # ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
a[:5]    # ['a', 'b', 'c', 'd', 'e']
a[:-1]   # ['a', 'b', 'c', 'd', 'e', 'f', 'g']
a[4:]    # ['e', 'f', 'g', 'h']
a[-3:]   # ['f', 'g', 'h']
a[2:5]   # ['c', 'd', 'e']
a[2:-1]  # ['c', 'd', 'e', 'f', 'g']
a[-3:-1] # ['f', 'g']

first_twenty_items = a[:20] # 원하는 길이를 쉽게 지정할 수 있다. 
last_twenty_items = a[-20:] # 거꾸로도 마찬가지이다. 

# a[:] = a[-0:] 이다 

b = a[3:] # 리스르틀 슬라이싱 한 결과는 완전히 새로운 리스트이다. 따라서 슬라이싱한 결과로 얻은 리스트를 변경해도 원래 리스트는 바뀌지 않는다. 
print('이전:', b)
b[1] = 99
print('이후:', b)
print('변화 없음:', a)

print('이전:', a)
a[2:7] = [99, 22, 14] # 지정한 슬라이스 길이보다 대입되는 배열의 길이가 더 짧거나 길어도 값이 대치된다. 
print('이후:', a)

print('이전:', a)
a[2:3] = [47, 11]
print('이후:', a)

b = a[:]
assert b == a and b is not a # 값은 동일하지만 a와 b는 서로 다른 객체이다. 원래 리스트를 복사한 새 리스트이기 때문이다. 

b = a # 위와는 다르게 작동된다. 서로 같은 객체이다. 
print('이전 a:', a)
print('이전 b:', b)
a[:] = [101, 102, 103]
assert a is b      # 여전히 같은 리스트 객체임
print('이후 a:', a) # 새로운 내용이 들어 있음
print('이후 b:', b) # 같은 리스트 객체이기 때문에 a와 내용이 같음
